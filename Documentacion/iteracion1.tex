%!TEX root =  tfg.tex
\chapter{Iteración 1: Escáner de Biodiversidad}

\begin{abstract}
Esta iteración aborda el núcleo funcional de Scubex: la capacidad de identificar especies marinas en una zona determinada. Se ha seguido un ciclo TDD para implementar la compleja lógica de integración y filtrado de datos entre múltiples APIs científicas.
\end{abstract}

\section{Características a desarrollar}

\begin{enumerate}
\item Escáner de Especies bajo demanda (Backend). Ver Tabla \ref{tab:valorAportadoScan}.
\item Filtrado y Enriquecimiento de Datos Biológicos.
\end{enumerate}

\begin{table*}[htb]
	\centering
	\begin{coolTable}{p{4cm}p{\textwidth-4.5cm}}{2}
{Análisis de valor aportado: Escáner de Especies}
\textbf{Propuesta}&Implementación de un endpoint REST que agregue datos de OBIS e iNaturalist para una zona geográfica.\\
\midrule
\textbf{Valor}&Permite al usuario descubrir fauna real validada científicamente sin conocimientos técnicos.\\
\textbf{Coste}&Alto esfuerzo de integración. Requiere orquestar llamadas asíncronas y gestionar distintos formatos de datos.\\
\textbf{Opciones}&Usar solo una API (OBIS) reduciría el coste, pero eliminaría el valor visual (fotos) y semántico (nombres comunes), haciendo la app inútil para turistas.\\
\textbf{Riesgos}&Rate limits de APIs externas. Inconsistencia de datos entre OBIS e iNaturalist.\\
\textbf{Deuda técnica}&Complejidad en la gestión de errores distribuidos (si una API falla).\\
	\end{coolTable}
	\caption{Análisis de valor aportado: Escáner\label{tab:valorAportadoScan}}
\end{table*}

\section{Diseño}

El diseño se centra en resolver la incompatibilidad entre la búsqueda radial del usuario y la búsqueda geométrica requerida por las fuentes de datos.

\begin{table*}[htb]
	\centering
	\begin{coolTable}{p{4cm}p{\textwidth-4.5cm}}{2}
{Memorando técnico 001: Geometría de Búsqueda}
\textbf{Asunto}&Incompatibilidad de búsqueda radial en API OBIS.\\
\textbf{Resumen}&Generación de polígonos WKT a partir de radio y centro.\\
\midrule
\textbf{Factores causantes}&El frontend solicita datos basados en un punto central y un nivel de zoom (radio), pero OBIS requiere un objeto `POLYGON` en formato WKT.\\
\textbf{Solución}&Implementar un servicio de utilidad geométrica que calcule los vértices de un cuadrado (o aproximación circular) inscrito en el radio de visión.\\
\textbf{Motivación}&OBIS ofrece la mayor base de datos científica, es imperativo adaptarse a su interfaz.\\
\textbf{Alternativas}&Filtrado post-proceso: Pedir un área muy grande y filtrar en memoria (descartado por ineficiencia).\\
	\end{coolTable}
	\caption{Memorando técnico 001: Geometría}
\end{table*}

\begin{table*}[htb]
	\centering
	\begin{coolTable}{p{4cm}p{\textwidth-4.5cm}}{2}
{Memorando técnico 002: Calidad de Datos}
\textbf{Asunto}&Presencia de microorganismos no visualizables.\\
\textbf{Resumen}&Filtrado cruzado mediante existencia de recursos en iNaturalist.\\
\midrule
\textbf{Factores causantes}&OBIS devuelve todo tipo de registros biológicos (ej. \textit{Pycnococcaceae}). Para una app turística/deportiva, estos datos son ruido.\\
\textbf{Solución}&Verificar cada nombre científico contra iNaturalist. Si `total\_results == 0` o no hay foto, se descarta el registro.\\
\textbf{Motivación}&Mantener la relevancia visual y la experiencia de usuario.\\
\textbf{Cuestiones abiertas}&El aumento de latencia por múltiples peticiones HTTP.\\
	\end{coolTable}
	\caption{Memorando técnico 002: Filtrado}
\end{table*}


\section{Implementación}

Se ha aplicado TDD para definir primero el comportamiento del orquestador de especies. A continuación se detalla el flujo principal.

\begin{asigResponsabilidad}{SCAN-01}{Orquestación de Escaneo}
{[List<Species>] scanSpecies (lat: Double, lng: Double, zoom: Integer)}
\pasoPseudo{1. Calcular radio de búsqueda basado en el nivel de zoom.}
\pasoPseudo{2. Generar polígono WKT (Well-Known Text) para el área definida.}
\pasoPseudo{3. Consultar OBIS API con el polígono para obtener ocurrencias raw.}
\pasoPseudo{4. Para cada especie única devuelta por OBIS:}
\pasoPseudo{4.1. Consultar iNaturalist API por nombre científico.}
\pasoPseudo{4.2. Si iNaturalist devuelve 0 resultados, descartar especie.}
\pasoPseudo{4.3. Si hay resultados, enriquecer con Foto y Nombre Común.}
\pasoPseudo{5. Retornar lista filtrada y ordenada.}
\cabeceraMetodosBajoNivel
\pasoCodigo{1}{ZoomUtils}{[Double] calculateRadius(zoom)}{001}{NO}
\pasoCodigo{2}{GeometryUtils}{[String] createPolygonWKT(lat, lng, radius)}{001}{NO}
\pasoCodigo{3}{ObisClient}{[List<ObisResult>] fetchOccurrences(wktPolygon)}{001}{NO}
\pasoCodigo{4.1}{INatClient}{[INatTaxon] searchTaxon(scientificName)}{002}{NO}
\pasoCodigo{4.2}{Stream}{filter(taxon -> taxon.getTotalResults > 0)}{002}{NO}
\diagramaColaboracion{figures/colDiagram.png}
\end{asigResponsabilidad}

\section{Pruebas}

Siguiendo TDD, se implementaron los siguientes casos antes del código productivo:

\begin{itemize}
    \item \textbf{shouldGenerateValidWKT}: Verifica que, dado un punto y radio, se genera un String `POLYGON(...)` geométricamente cerrado.
    \item \textbf{shouldFilterMicroorganisms}: Mockea una respuesta de OBIS con \textit{Pycnococcaceae} y verifica que, al simular una respuesta vacía de iNaturalist, el servicio retorna una lista vacía.
\end{itemize}

\section{Despliegue}

El backend se ha empaquetado como un JAR ejecutable (Spring Boot) y se despliega junto con la configuración de credenciales para las APIs externas.